// #include "RecoParticleFlow/PFClusterTools/interface/PFEnergyCalibration.h"
// #include "CondFormats/PhysicsToolsObjects/interface/PerformancePayloadFromTFormula.h"
// #include "PerformancePayloadFromTFormula.h" // already in .h

// #include "CondFormats/ESObjects/interface/ESEEIntercalibConstants.h"

#include <TMath.h>
#include <cmath>
#include <vector>
#include <map>
#include <algorithm>
#include <numeric>
#include <array>

#include "TH1D.h"
#include "TF1.h"

using namespace std;

bool debug = false;

TH1D *heta(0);
TF1 *pfec_f1hh(0), *pfec_f1he(0);
PFEnergyCalibration::PFEnergyCalibration() {

  // Functions needed to invert response when true energy not given
  pfec_f1hh = new TF1("f1hh","max([3],[0]*(1-[1]*pow(x,[2]-1)))*x",0.2,5000);
  pfec_f1he = new TF1("f1he","max([3],[0]*(1-[1]*pow(x,[2]-1)))*(1-[8])*x+"
		      "max([7],[4]*(1-[5]*pow(x,[6]-1)))*[8]*x",0.2,5000);

// Array auto-generated by pfhc/drawPionGun.C
// Hadron response |eta| bins
  const int neta = 29;
  double veta[neta+1] =
    {0.000, 0.087, 0.174, 0.261, 0.348, 0.435, 0.522, 0.609, 0.696, 0.783,
     0.879, 0.957, 1.044, 1.131, 1.218, 1.305, 1.392, 1.479, 1.566, 1.653,
     1.740, 1.830, 1.930, 2.043, 2.172, 2.322, 2.500, 2.650, 2.853, 2.964};
  
  // Histogram to make finding |eta| bin easier
  heta = new TH1D("heta",";|#eta|;", neta, &veta[0]);

} // PFEnergyCalibration


void PFEnergyCalibration::energyEmHad(double t, double& e, double& h, double eta, double phi) const {

  // NB: following arrays can be moved back to outside function call to be
  // static arrays. Using old C-style here for debugging purposes
  
// Parameter arrays auto-generated by pfhc/drawPionGun.C
// H-hadron response (c, a, m, R_h,min)
//array< array<double, 4>, 29> vhh = {{
  const double vhh[29][4] = {
    {1.0224, 0.6794, 0.5123, 0.6500}, // [0.000,0.087]
    {1.0301, 0.6165, 0.5628, 0.6500}, // [0.087,0.174]
    {1.0513, 0.5692, 0.6151, 0.6500}, // [0.174,0.261]
    {1.0672, 0.5434, 0.6490, 0.6500}, // [0.261,0.348]
    {1.0518, 0.6291, 0.5700, 0.6500}, // [0.348,0.435]
    {1.0509, 0.6154, 0.5725, 0.6500}, // [0.435,0.522]
    {1.0727, 0.5692, 0.6203, 0.6500}, // [0.522,0.609]
    {1.0995, 0.5211, 0.6794, 0.6500}, // [0.609,0.696]
    {1.1140, 0.5036, 0.7116, 0.6500}, // [0.696,0.783]
    {1.1031, 0.5548, 0.6588, 0.6500}, // [0.783,0.879]
    {1.1067, 0.5406, 0.6747, 0.6500}, // [0.879,0.957]
    {1.1210, 0.5524, 0.6586, 0.6500}, // [0.957,1.044]
    {1.1458, 0.5076, 0.7060, 0.6500}, // [1.044,1.131]
    {1.1197, 0.5677, 0.6597, 0.6500}, // [1.131,1.218]
    {1.1551, 0.5761, 0.6951, 0.6500}, // [1.218,1.305]
    {1.2437, 0.6514, 0.7321, 0.6500}, // [1.305,1.392]
    {1.1943, 0.5580, 0.7117, 0.7500}, // [1.392,1.479]
    {1.0454, 0.4553, 0.6596, 0.7500}, // [1.479,1.566]
    {1.0814, 0.5293, 0.4835, 0.7500}, // [1.566,1.653]
    {1.0680, 0.5637, 0.4722, 0.7500}, // [1.653,1.740]
    {1.0436, 0.6542, 0.3470, 0.6500}, // [1.740,1.830]
    {1.0560, 0.6679, 0.3141, 0.6500}, // [1.830,1.930]
    {1.0509, 0.7848, 0.2552, 0.6500}, // [1.930,2.043]
    {1.0253, 1.0691, 0.1093, 0.6500}, // [2.043,2.172]
    {1.0009, 1.2000, 0.0625, 0.6000}, // [2.172,2.322]
    {1.0364, 1.2000, 0.1902, 0.6000}, // [2.322,2.500]
    {1.1029, 1.2000, 0.3792, 0.5000}, // [2.500,2.650]
    {1.1312, 1.2000, 0.4989, 0.5000}, // [2.650,2.853]
    {1.4000, 0.9871, 0.7817, 0.4000} // [2.853,2.964]
    //}};
  };

// EH-hadron H-component response (c, a, m, R_eh,min)
//array< array<double, 4>, 29> veh = {{
 const double veh[29][4] = {
    {0.9172, 1.0650, 0.5182, 0.5000}, // [0.000,0.087]
    {0.9149, 1.0344, 0.5316, 0.5000}, // [0.087,0.174]
    {0.9233, 0.9809, 0.5564, 0.5000}, // [0.174,0.261]
    {0.9262, 0.9465, 0.5671, 0.5000}, // [0.261,0.348]
    {0.9355, 0.8800, 0.5856, 0.5000}, // [0.348,0.435]
    {0.9294, 0.9846, 0.5659, 0.5000}, // [0.435,0.522]
    {0.9358, 0.9478, 0.5890, 0.5000}, // [0.522,0.609]
    {0.9374, 0.9341, 0.5943, 0.5000}, // [0.609,0.696]
    {0.9677, 0.8501, 0.6484, 0.5000}, // [0.696,0.783]
    {0.9612, 0.9267, 0.6306, 0.5000}, // [0.783,0.879]
    {0.9733, 0.8911, 0.6489, 0.5000}, // [0.879,0.957]
    {0.9679, 0.9863, 0.6156, 0.5000}, // [0.957,1.044]
    {0.9662, 0.9951, 0.6075, 0.5000}, // [1.044,1.131]
    {0.9672, 0.9532, 0.6473, 0.5000}, // [1.131,1.218]
    {0.9409, 0.9093, 0.6432, 0.5000}, // [1.218,1.305]
    {1.3416, 0.7301, 0.9000, 0.5000}, // [1.305,1.392]
    {1.3426, 0.7114, 0.9000, 0.5000}, // [1.392,1.479]
    {1.0509, 0.9346, 0.5124, 0.7000}, // [1.479,1.566]
    {1.0240, 1.0015, 0.4492, 0.6000}, // [1.566,1.653]
    {1.0110, 0.9938, 0.5124, 0.6000}, // [1.653,1.740]
    {1.0001, 1.1848, 0.4140, 0.6000}, // [1.740,1.830]
    {1.0018, 1.2000, 0.3980, 0.6000}, // [1.830,1.930]
    {1.0139, 1.1102, 0.4418, 0.6000}, // [1.930,2.043]
    {0.9968, 1.2000, 0.4175, 0.6000}, // [2.043,2.172]
    {0.9955, 1.1266, 0.4548, 0.6000}, // [2.172,2.322]
    {1.0706, 0.9704, 0.5935, 0.6500}, // [2.322,2.500]
    {1.0822, 1.0997, 0.5790, 0.7000}, // [2.500,2.650]
    {1.4000, 0.8790, 0.8136, 0.6500}, // [2.650,2.853]
    {1.4000, 0.8582, 0.8720, 0.5000} // [2.853,2.964]
    //}};
 };

// EH-hadron E-component response (c, a, m, R_ee,min)
//array< array<double, 4>, 29> vee = {{
 const double vee[29][4] = {
    {1.3621, 1.2000, 0.7941, 0.3500}, // [0.000,0.087]
    {1.3704, 1.2000, 0.7954, 0.3500}, // [0.087,0.174]
    {1.3503, 1.1968, 0.7919, 0.3500}, // [0.174,0.261]
    {1.4000, 1.1746, 0.8054, 0.3500}, // [0.261,0.348]
    {1.3824, 1.1901, 0.7994, 0.3500}, // [0.348,0.435]
    {1.4000, 1.1701, 0.8073, 0.3500}, // [0.435,0.522]
    {1.4000, 1.1357, 0.8123, 0.3500}, // [0.522,0.609]
    {1.4000, 1.1388, 0.8121, 0.3500}, // [0.609,0.696]
    {1.4000, 1.1453, 0.8104, 0.3500}, // [0.696,0.783]
    {1.4000, 1.1240, 0.8174, 0.3500}, // [0.783,0.879]
    {1.4000, 1.1246, 0.8143, 0.3500}, // [0.879,0.957]
    {1.4000, 1.0962, 0.8226, 0.3500}, // [0.957,1.044]
    {1.4000, 1.1052, 0.8219, 0.3500}, // [1.044,1.131]
    {1.4000, 1.0977, 0.8264, 0.3500}, // [1.131,1.218]
    {1.4000, 1.0669, 0.8300, 0.3500}, // [1.218,1.305]
    {1.2343, 1.0188, 0.8154, 0.3500}, // [1.305,1.392]
    {0.9402, 1.2000, 0.6958, 0.3500}, // [1.392,1.479]
    {1.4000, 0.9518, 0.8488, 0.2500}, // [1.479,1.566]
    {1.4000, 1.0613, 0.8150, 0.2500}, // [1.566,1.653]
    {1.4000, 1.0722, 0.8211, 0.2500}, // [1.653,1.740]
    {1.4000, 1.0939, 0.8096, 0.2500}, // [1.740,1.830]
    {1.4000, 1.1049, 0.8052, 0.2500}, // [1.830,1.930]
    {1.4000, 1.1121, 0.8015, 0.2500}, // [1.930,2.043]
    {1.4000, 1.1049, 0.8024, 0.2500}, // [2.043,2.172]
    {1.4000, 1.1215, 0.7976, 0.2500}, // [2.172,2.322]
    {1.4000, 1.1646, 0.7929, 0.2500}, // [2.322,2.500]
    {1.4000, 1.2000, 0.7841, 0.2500}, // [2.500,2.650]
    {1.0500, 1.2000, 0.6576, 0.2500}, // [2.650,2.853]
    {0.9000, 1.1858, 0.6258, 0.2500} // [2.853,2.964]
   //}};
};
  
  // Save input energies in const form
  const double tt = t;
  const double ee = e;
  const double hh = h;

  // True pT from true energy
  double pt = tt / cosh(eta);
  
  // Retrieve parameters of H, E of HE and H of HE for given abseta bin
  double abseta = fabs(eta);
  const int neta = heta->GetNbinsX();
  int ieta = heta->GetXaxis()->FindBin(abseta);
  ieta = max(1,min(neta,ieta))-1;
  //array<double, 4>& phh = vhh[ieta];
  //array<double, 4>& peh = veh[ieta];
  //array<double, 4>& pee = vee[ieta];
  const double *phh = vhh[ieta];
  const double *peh = veh[ieta];
  const double *pee = vee[ieta];
  
  // Calculate raw ECAL fraction to decide H vs EH and to calculate EH
  const double fe = (ee+hh>0 ? ee / (ee + hh) : 0.);

  // Solutions of power law form y = c*(1 - a*pow(x,m-1)) are well-defined
  // for x only when dy/dx > 0, i.e. x > pow(am,1/(1-m)) for c,a,m>0 and m<1
  // Enforcing these limits avoids ROOT::Math::BrentRootFinder errors?
  double minxh =  max(1., pow(phh[1]*phh[2], 1./(1-phh[2])));
  double minxeh = max(1., pow(peh[1]*peh[2], 1./(1-peh[2])));
  double minxee = max(1., pow(pee[1]*pee[2], 1./(1-pee[2])));
  double minxe = minxeh*(1-fe) + minxee*fe;
  
  // If true energy is not given, invert response function(s) to get true pT
  if (!(tt>0)) {

    double k = 1./cosh(eta); // for E->pT 

    // H-hadron with single power law
    pfec_f1hh->SetRange(minxh,5000.);
    pfec_f1hh->SetParameters(phh[0],phh[1],phh[2],phh[3]);
    double pt_hh = pfec_f1hh->GetX(max(phh[3]*minxh, hh*k),
				   max(minxh,phh[3]*hh*k),
				   max(minxh,1.40*hh*k)) + ee*k;

    // EH-hadron with two power laws weighted vs f_ECAL
    pfec_f1he->SetRange(minxe,5000.);
    pfec_f1he->SetParameters(peh[0],peh[1],peh[2],peh[3],
			     pee[0],pee[1],pee[2],pee[3], fe);
    double pt_eh = pfec_f1he->GetX(max((pee[3]*fe+0.5*(1-fe))*minxh, (hh+ee)*k),
				   max(minxe,(peh[3]*hh+pee[3]*ee)*k),
				   max(minxe,1.40*(hh+ee)*k));

    // User raw ECAL fraction to decide correct case to apply
    if (fe<0.01) { // Clear H hadron
      pt = pt_hh;
    }
    else if (fe>0.1) { // Clear EH hadron
      pt = pt_eh;
    }
    else { // Transition region between the two
      double x = (fe-0.01)/(0.1-0.01);
      pt = (1-x) * pt_hh + x * pt_eh;
    }
  } // !(tt>0)
  
  // Calculate responses for H hadrons and for E,H components of HE
  // Response limits at low end are important to stabilize behavior
  // Use best estimates from plots, but could be fit per |eta| bin in future
  double rh =  max(phh[3], phh[0]*(1 - phh[1]*pow(max(pt,minxh), phh[2]-1)));
  double reh = max(peh[3], peh[0]*(1 - peh[1]*pow(max(pt,minxeh), peh[2]-1)));
  double ree = max(pee[3], pee[0]*(1 - pee[1]*pow(max(pt,minxee), pee[2]-1)));
  double re = reh*(1-fe) + ree*fe;
  
  // Calculate total corrected energies under both H and EH hypotheses
  double ehh = (hh + ee) / rh;
  double ehe = (hh + ee) / re;

  // Re-distribute EH correction to ECAL and HCAL components
  // Example case: ree=reh => we=fe
  // Example case: fe=0 => we=0, fe=1 => we=1
  double we = (fe/ree) / (fe/ree + (1-fe)/reh);

  // Same for H hadrons, assuming ree=1 (for MIPs)
  // Example case: rh=ree=1 => wh=(1-fe)
  // Example case: fe=0 => wh=1, fe=1 => wh=0
  double wh = (1-fe)/rh / (fe + (1-fe)/rh);
  
  // Use raw ECAL fraction to decide correct case to apply
  if (fe<0.01) { // Clear H hadron
    //e = ee;
    //h = hh / rh;
    e = ehh * (1-wh);
    h = ehh * wh;
  }
  else if (fe>0.1) { // Clear EH hadron
    //e = ee / re;
    //h = hh / re;
    e = ehe * we;
    h = ehe * (1-we);
  }
  else { // Transition region between the two
    double x = (fe-0.01)/(0.1-0.01);
    //e = (1-x) * ee + x * (ee / re);
    //h = (1-x) * (hh / rh) + x * (hh / re);
    //e = (1-x) * ee + x * (ehe * we);
    //h = (1-x) * (hh / rh) + x * (ehe * (1-we));
    e = (1-x) * (ehh * (1-wh)) + x * (ehe * we);
    h = (1-x) * (ehh * wh) + x * (ehe * (1-we));
  }

  if (debug) {
    cout << "PFEnergyCalibrationFromMikko.cc:" << endl;
    cout << " tt = " << tt
	 << " hh = " << hh
      	 << " ee = " << ee
	 << " eta = " << eta
      	 << " phi = " << phi << endl
	 << " ieta = " << ieta
      	 << " neta = " << neta
	 << " (etamin=" << heta->GetBinLowEdge(ieta+1) << ","
      	 << " etamid=" << heta->GetBinCenter(ieta+1) << ","
      	 << " etamax=" << heta->GetBinLowEdge(ieta+2) << ")" << endl
      	 << " h = " << h
      	 << " e = " << e
	 << " corr = " << (e+h)/(ee+hh)
	 << endl << flush;
  }
  
  return;
} // energyEmHad

